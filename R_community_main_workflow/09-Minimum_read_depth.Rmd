# Minimum read depth
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/depth_diver.png", auto_pdf = TRUE)
``` 

It is good to remove samples with a very low read depth (number of sequencing reads).
However, it is not trivial to determine what an appropriate read depth is.
This value will vary from study to study.
Normally, for 16S data, a depth of at least 20K per sample is suggested. However, this is the general consensus for human microbiome data. 

In this chapter we will:

- Cover a brief intro to considertions of what is an acceptable minimum depth for your dataset.
- Reinvestigate our sample depths with a previously created histogram.
- View the depth ranges of different sample groups (site & media) with box plots.
- Create a rarefaction curve to assess if the depth of our samples have captured a good amount of biodiversity.
- Demonstrate how to filter samples by depth.

## Considerations
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/consider.png", auto_pdf = TRUE)
``` 

There are 3 main considerations to take into account for what is an appropriate depth for your dataset.

- __The biodiversity of your samples.__
  - If your sample is very biodiverse, such as the human gut microbiome, you will need a good depth (>20K per sample).
  - If your sample is less biodiverse, such as many geological environments or skin, then you will not need as much read depth.
  - Rarefaction curves are a good method to determine if your samples have enough depth. We will look at this in this chapter.
- __The biomass of your samples.__
  - Some environments are hard to extract DNA from.
  - If this is the case for you, then people will hopefully accept that this is an unfortunate reality of life and you will use what you can.
  - However, be careful of your conclusions, if you think your data doesn't have as much as it could do not make very definitive detailed claims.
- __Read depth of sample groups.__
  - It may be possible that a few samples have a much lower depth than the rest and so you may think to remove them.
  - However, these may all come from the same sample group and so you have lost all information of one group.
  - For instance, you may be comparing different geological surfaces and your rock samples have much lower read depths than the various soil samples.
  - For comparisons including the lower depth sample group (e.g. rock samples) you will need to retrain the lower depth sample.

That is a brief overview of that topic. If you are interested in more I suggest you look at papers where they have studied an environment similar to yours.

## Minimum read depth section title
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/header_l2.png", auto_pdf = TRUE)
``` 

In the next section of our `jupyter-notebook` we will investigate what the minimum read depth should be and remove sample below this.

Create a new __"Markdown"__ cell and add the following 2nd level header.

```{r, eval=FALSE}
## Minimum read depth
```

## Read depth vector and histogram
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/histogram.png", auto_pdf = TRUE)
```

We have already created a vector and histogram of the read depths across our samples. Scroll up your notebook to view these and answer the following MCQ:

```{r, echo = FALSE}
opts_p <- c("__1-8__", answer="__10,000-18,000__", "__20,000+__")
```
- What is the approximate read depth range of our dataset? `r longmcq(opts_p)`

This is a good first step but what if we want to know how the read depths vary between sample groups?

## Sample depth boxplot
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplot.png", auto_pdf = TRUE)
```

We are going to use `ggplot2` to create a couple boxplots to show the sequencing depth ranges of the different sample groups (Site & Media).

### Creating data frame for boxplots
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/metadata.png", auto_pdf = TRUE)
```

First, we need to create an object containing our sample names, Site & Media information, and the depth.
We will use this object to produce our boxplots.
Thankfully the metadata in our `phyloseq` object contains all this information except the depth.

In a new cell write and run the below code. This will extract the sample data (metadata) to a new object and display the top 6 rows fo this new object.

```{r, eval=FALSE}
#Extract sample data as a separate R object
abundance_metadf <- phyloseq::sample_data(pseq)
#View top 6 rows of metadata data frame
head(abundance_metadf)
```

The 2 new functions above are:

- `phyloseq::sample_data()`: Extracts the sample data (metadata) data frame from a `phyloseq` object.
- `head()`: Returns the first 6 parts of an R object by default.
  - It can be used for a vector, matrix, table, data frame, or function.
  - In the case of a data frame it returns the first 6 rows.

We need to add the depth information to our new data frame. 
We have extracted this previously into an object called `sample_depths`. 
However, before adding it we want to check it has the same order of samples as the rows in `abundance_metadf`.

Write and run the below script in the same cell. The code uses `head()` to view the first 6 elements of `sample_depths` and the row names of `abundance_metadf`. Then the function `idnetical()` is used to see if they are identical (`TRUE`) or not (`FALSE`).

```{r, eval=FALSE}
#Check if our vector of sample_depths has the same order as our metadata rows
head(names(sample_depths))
head(row.names(abundance_metadf))
identical(names(sample_depths),row.names(abundance_metadf))
```

The order of samples is identical so we can add the depth information to `abundance_metadf`. Carry this out in the same cell with the code below.

```{r, eval=FALSE}
#Add sample depths to metadata data frame
abundance_metadf[,"depth"] <- sample_depths
#View top 6 rows of edited metadata dataframe
head(abundance_metadf)
```

Great! We will next use this data frame to create 2 boxplots.

### Depth boxplots
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplots_groups.png", auto_pdf = TRUE)
```

We are going to create 2 boxplots with `ggplot2`.
We won't go into too much detail on how the code works here, instead learning more later in this book.

The code below creates a `ggplot2` boxplot. We carry this out with 2 functions:

- `ggplot()`: This creates a `ggplot2` object, storing the information and aesthetics.
  - The first option is the data we want to use for plotting (`abundance_metadf`).
  - The second option is the aesthetics (`aes()`) to plot. In this case we want the depth column to be plotted on the y-axis (`y=depth`) and the site column to be plotted on the x-axis (`x=site`).
- `+`: We need to have a `+` at the end of the `ggplot()` function to add the next component of the plot.
- `geom_boxplot()`: This adds a layer to our `ggplot2` object. In this case it converts the `ggplot` object, which is just information, into a boxplot.

Write and run the following code in a new cell:

```{r, eval=FALSE}
#Create ggplot2 boxplot of depth by size
ggplot2::ggplot(abundance_metadf, aes=(y=depth, x=site)) +
  ggplot2::geom_boxplot()
```

```{r, echo = FALSE}
opts_p <- c(answer="__LD (Lower Durance)__", "__MD (Middle Durance)__", "__UD (Upper Durance__")
```
- Which site has the highest median depth (middle line of boxplot)? `r longmcq(opts_p)`

We will use the same code to plot the depth by media.
You can copy and paste the code changing the x aesthetic to media (`x=media`).
Carry this out in the same cell and run the code.

```{r, eval=FALSE}
#Create ggplot2 boxplot of depth by size
ggplot2::ggplot(abundance_metadf, aes=(y=depth, x=media)) +
  ggplot2::geom_boxplot()
```

```{r, echo = FALSE}
opts_p <- c(answer="__CVP__", "__ENV__", "__TSA__")
```
- Which media has the lowest median depth (middle line of boxplot)? `r longmcq(opts_p)`

From the boxplots we can see there is no drastic difference between the depths of the different sample groups. We will therefore continue and make some rarefaction curves to further assess the depth of our samples.

For more resources on `ggplot2` please see the [appendix](#ggplot2_appendix) of this book.

## Rarefaction curve
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/rarefaction.png", auto_pdf = TRUE)
```

Our read depths appear a bit low, each sample has <20K reads. 
However, this might be fine for our dataset since we are using surface water samples rather than human gut microbiome samples.
Let's see how our samples look with a rarefaction curve.

__Note__: This is a quick example and we will go into more detail in the [rarefaction chapter](#rarefaction_chap).

Surprisingly, there is not a good method to produce a rarefaction curve with the `phyloseq` or `microbiome` packages. 
We will therefore use the [`vegan`](https://vegandevs.github.io/vegan/) package. 
`vegan` is an R package for community ecologists. 
It has a variety of functions but it uses normal R data frames rather than `phyloseq` objects.
We will therefore only use it for rarefaction purposes.

### ASV abundance data frame
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/nice_table.png", auto_pdf = TRUE)
```

Before creating our rarefaction curve we will extract the ASV abundance table from the `phyloseq` object with `phyloseq`'s function `otu_table()`. 
We need to transpose (`t()`) the table so it is in the correct orientation for the rarefaction function.
Additionally, we ensure it is a data frame with the function `as.data.frame()`.

Carry this out in a new cell.

```{r, eval=FALSE}
#Rarefaction curve
#Extract ASV table as data frame
asv_abund_df <- as.data.frame(t(phyloseq::otu_table(pseq)))
```

### vegan's rarecurve
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/vegan.png", auto_pdf = TRUE)
```

With this data frame we can create a rarefaction curve with `vegan`'s `rarecurve()` function.

Add the following code to the same cell and run it.

```{r, eval=FALSE}
#Rarefaction curve
vegan::rarecurve(
  x = asv_abund_df, step = 50,
  xlab = "Read depth",
  ylab = "ASVs"
)
```

In essence, we are hoping that the majority of samples have plateau'd.
If the curves have flattened in relation to the y axis this indicates that most of the ASVs present in the sample have been captured.

In this case the samples have plateau'd or have gentle slopes towards the end.
With this we can be happy to continue and not remove samples by a minimum read depth.

If we saw some samples with steep curves which had low depths we could carry out some more analysis with rarefaction.
However, more rarefaction functions, analysis, and theories will be covered in the [rarefaction chapter](#rarefaction_chap).
You could use some of these at this point to help you determine your minimum read depth for your own datasets.

## Filtering by minimum read depth
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/water_filter.png", auto_pdf = TRUE)
```

What if you want to filter samples by a minimum read depth?

In that case you can use the `subset_samples()` function from `phyloseq()`.
We will use our previously created vector containing read depths (`sample_depths`) to remove sample with less than 11k reads.
We have chosen this depth as an example to remove some samples.

Write and run the below code in a new cell.
It will create a new subsetted `phyloseq` object.

```{r, eval=FALSE}
#Subset and keep samples with at least 11k reads
pseq_min11K <- phyloseq::subset_samples(pseq, reads_sample > 11000)
```

After removing samples it is also useful to remove ASVs with no abundance values.
This can occur when ASVs are only present in the samples which have been removed.

To remove these ASVs we can use two `phyloseq` functions:

- __`taxa_sums()`__: Returns a vector showing sum of all taxa in the abundance table. 
  - In our `phyloseq` object the ASVs are the taxa. 
  - ASVs have long human unfriendly names that are unique to every single ASV possible.
- __`prune_taxa()`__: This retains taxa/ASVs based on a provided vector.
  - In this case we are creating a logical vector (`TRUE`/`FALSE`) where ASVs with 0 abundance are `FALSE` and ASVs with abundance > 0 are `TRUE`.

We'll first write and run some commands with `taxa_sums()` to get some practice with it. Carry this out int he same cell as the `subset_samples()` command.

```{r, eval=FALSE}
#Abundance sums of the 1st six ASVs
head(phyloseq::taxa_sums(pseq_min11K))
#View number of ASVs in our data
length(phyloseq::taxa_sums(pseq_min11K))
```

In the same cell add the following.
This will filter out ASVs with no abundance.

```{r, eval=FALSE}
#Remove ASVs with no abundance
pseq_min11k <- phyloseq::prune_taxa(
  phyloseq_taxa_sums(pseq_min11k) > 0, pseq_min11k
)
```

Finally, summarise the contents of the `phyloseq` object. 
Add the following in the same cell and then run the code in the cell.

```{r, eval=FALSE}
#Summarise subsetted phyloseq
microbiome::summarize_phyloseq(pseq_min11K)
microbiome::readcount(pseq_min11K)
pseq_min11k
```

We can see that the data lost 26 ASVs (2551 - 2525).

Try to write your own R code in a new cell to answer the following questions:

```{r, echo = FALSE}
opts_p <- c("__4__", answer="__613__", "__42507__")
```
- What is the difference of the minimum number of reads between `pseq_min11k` and `pseq`? r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__4__", "__613__", "__42507__")
```
- How many samples were removed due to the read depth filtering? r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__4__", "__613__", answer="__42507__")
```
- What is the difference of the minimum number of reads between `pseq_min11k` and `pseq`? r longmcq(opts_p)`

`r hide("Tip")`
Combining `microbiome::readcount()` with `min()`, `length()`, and `sum()` might help.
`r unhide()`

`r hide("Code solutions + bonus")`
```{r, eval=FALSE}
#Difference of minimum read numbers
min(microbiome::readcount(pseq_min11k)) - min(microbiome::readcount(pseq))
#Number of samples lost
length(microbiome::readcount(pseq)) - length(microbiome::readcount(pseq_min11k))
#Number of reads removed
sum(microbiome::readcount(pseq)) - sum(microbiome::readcount(pseq_min11k))
#Bonus
#List the removed samples
setdiff(phyloseq::sample_names(pseq)), phyloseq::sample_names(pseq_min11k))
```
`r unhide()`

We won't actually use this subsetted file as we want to keep all the samples in this case.
Additionally, since we didn't need remove any samples we don't need to remove any ASVs as they should all have a total abundance > 0.
Therefore you can remove the `phyloseq` object in a new cell.

```{r, eval=FALSE}
#Remove subsetted phyloseq
rm(pseq_min11K)
```

Once you are finished with this notebook you can save it then close and halt it.

## Minmum read depth: Summary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_blue.png", auto_pdf = TRUE)
```

We have assessed the read depth in this chapter and decided to not remove any samples. 
This assessment included:

- Viewing a histogram of sample read depths.
- Creating boxplots to compare the sample read depths across sample groups (siet and media).
- Producing a rarefaction depth to determine if any samples did not represent a good amount of the ASVs present in the environment.

Additionally, we created a new `phyloseq` object where the samples were filtered by depth.
Ultimately we did not keep the filtered `phyloseq` object.
