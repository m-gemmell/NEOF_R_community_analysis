--- 
title: "R community analysis"
author: "Matthew R. Gemmell"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
favicon: figures/NEOF_favicon.png
description: NEOF book for the R community analysis workflow
cover-image: "figures/NEOF.png"
---
```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```

```{r cite-packages, include = FALSE}
# automatically create a bib database for R packages
# add any packages you want to cite here
knitr::write_bib(c(
  .packages(), 'bookdown', 'webexercises'
), 'packages.bib')
```

```{r, fig.align = 'center',out.width= '30%', echo=FALSE }
knitr::include_graphics(path = "figures/NEOF.png", auto_pdf = TRUE)
``` 

# (PART\*) Intro {-}

# Introduction
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R_community.png", auto_pdf = TRUE)
``` 

A lot of different analysis and visualisations can be carried out with community data. This includes taxonomy and functional abundance tables from 16S rRNA and Shotgun metagenomics analysis. This workshop will teach you how to use R with the phyloseq R object; a specialised object containing an abundance, taxonomy, and metadata table. 

The workshop will use a 16S dataset that has been pre-analysed with QIIME2 to create the ASV table, taxonomy table, and phylogenetic tree. Supplementary materials will show how to import Bracken shotgun metagenomic abundance data and generic abundance data frames into a phyloseq object.
 
Sessions will start with a brief presentation followed by self-paced computer practicals guided by an online interactive book. The book will contain theory and practice code. This will be reinforced with multiple choice questions that will recap concepts and aid in interpretation of results.

At the end of the course learners will be able to:

- Import QIIME2 artifacts into a phyloseq object.
- Summarise the abundance and taxonomy contents of a phyloseq object
- Preprocess the abundance and taxonomy tables. This will include transforming sample counts, and subsetting samples & taxonomies.
- Understand the grammar of graphics (ggplot2) used by phyloseq and related packages.
- Carry out alpha & beta diversity, and biomarker detection with the phyloseq object.
- Produce and customise publication quality plots.
- Run statistical analysis and incorporate these values into the plots.
- Convert static plots into interactive html plots with plotly within R.



<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.

<!--chapter:end:01-R_community_main_workflow.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Dataset & workflow
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/data.png", auto_pdf = TRUE)
``` 

## Dataset
```{r, fig.align = 'center',out.width= '50%', echo=FALSE }
knitr::include_graphics(path = "figures/freshwater_france.png", auto_pdf = TRUE)
``` 

In this tutorial we will be using 16S metabarcdoing datasets derived from surface water from the Durance River in the south-east of France. Two major comparisons were carried out in combination with each other.

### Sites
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/river.png", auto_pdf = TRUE)
``` 

Three different sites were chosen on the Durance River. These three sites were representative of an anthropisation (transformation of land by humans) gradient along a river stream. These sites were:

- __Upper Durance sampling site (UD)__: Bottom part of the alpine part of the river with little/no anthropisation.
- __Middle Durance sampling site (MD)__: Upper part of agricultural land dominated by apple and pear production.
- __Lower Durance sampling site (LD)__: Lower part of agricultural land with intensive production of fruits, cereals, and vegetables.

### Culture media
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/petri.png", auto_pdf = TRUE)
```

Surface water was sampled and different culture media were used to produce bacterial lawns for each site. The media used were:

- __Environmental sample (ENV)__: No media used, frozen at -20°C will DNA extraction.
- __TSA 10%__ incubated at 28°C for 2 days.
- __KBC__ incubated at 28°C for 2 days.
- __CVP__ incubated at 28°C for 3 days.

### Summary & questions
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_red.png", auto_pdf = TRUE)
```

Each sample and media combination was produced in replicates of three giving a total of 27 samples (3*4*3 = 36). The three replicates were cultured on three different plates with the same media. An ASV table, taxonomy table, and phylogenetic tree were produced with QIIME2 and DADA2.

With this data we can ask and investigate the following questions:

- How does the bacterial communities change across the anthropisation gradient?
- Is there a difference in the replicates of one site and media combination. I.e. do any of the media produce inconsistent profiles.
- Is there more difference between the sites or the media used?
- Do any of the media produce a similar taxonomic profile to the environmental sample?


## Workflow
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/workflow.png", auto_pdf = TRUE)
```


<!--chapter:end:02-Dataset_and_workflow.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# R Packages
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/R.png", auto_pdf = TRUE)
```  

During this workshop we will use various R packages with their own intricacies. Before going into analysis we'll introduce you to some of these important concepts.

## R packages/libraries
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/r_package.png", auto_pdf = TRUE)
```

R packages/libraries contain additional functions, data and code for analysing, manipulating and plotting different types of data. Many common packages will be installed as default when you install R. Other more specialised packages, such as the `ggplot2` package, must be installed by the user.

Packages found on The Comprehensive R Archive Network (CRAN) which is R’s central software repository can be installed easily using the following command.

```{r eval=FALSE}
install.packages("package_name")
```

Every time you reload R you will need to load the packages you need if they are not one of the ones installed by default. To do this type:

```{r eval=FALSE}
library("package_name")
```

I generally have a list of `library()` functions at the top of my R scripts (`.R` files) for all the packages I use in the script.

Throughout this course you will get a lot of practice installing and loading various packages.

`r hide("R package or R Library?")`
R packages are a collection of R functions, data, and compiled code. You can install these into a directory on your computer.

An R library is a directory containing a R package.

Because of this, the terms R package and R library may be used synonymously. We will use the term package in this workshop.
`r unhide()`

As we will be using a lot of packages we shall use a double colons to specify which package each function belongs to, unless the function is from base R. For example if we use the function `summarize_phyloseq()` from the package `microbiome` we would type the function like below:

__Note__: Do not run the below command.

```{r eval=FALSE}
microbiome::summarize_phyloseq()
```

This convention has 2 benefits:

- We can easily tell which R package each function comes from.
  - This is useful for your future coding where you may copy some, but not all, commands from one script to another. You will therefore know which packages you will need to load.
  - If you need some more documentation about a function you will know what package to look up.
  - Writing your methods will be a lot easier.
- Different packages may have functions with the same name. Specifying the package will ensure you are using the correct function.

## The grammar of graphics
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/ggplot2.png", auto_pdf = TRUE)
``` 

During this course we will be using the grammar of graphics coding approach. This approach is implemented by the R package `ggplot2` to create visualisations such as bar charts, box plots, ordination plots etc. In turn `ggplot2` is used by a host of other packages, some of which we will be using. Although `ggplot2` is R code its structure is very different and it takes effort to learn. Thankfully, `ggplot2` is very powerful and flexible, and it produces very professional and clean plots.

We will use the `iris` dataset (inbuilt into R) to show an example of `ggplot2` code and its visualisation output is:

__Note__: If you would like to see the contents of the `iris` dataset you can run the command `View(iris)` in your R instance.

```{r}
#Load library
library(ggplot2)

#Create new ggplot2 object using iris dataset
ggplot2::ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width, colour=Species)) +
  #Make the object a scatter plot 
  ggplot2::geom_point() +
  #Add plot tile
  ggplot2::ggtitle("Iris Sepal length vs width") +
  #Set x and y axis label names
  ggplot2::labs(x = "Sepal length", y = "Sepal width")
```

We will not learn `ggplot2` specifically during this course. However, the structure of creating an object will be used. In the above case the initial object was built with `ggplot`. Subsequently additions and edits were carried out with `+` and various other functions.

An important concept of the grammar of graphics is aesthetics. Aesthetics are the parts of a graphic/plot. In the above command we set the aesthetics with the function `aes()` within the `ggplot()` function. The X aesthetic (i.e. what values are assigned to the x axis) was set as the Sepal length values from the column `Sepal.Length` of the dataframe `iris`. In turn the Y axis values are set to the Sepal width and the colouring of the points are set to the Species.

That was a quick introduction to the grammar of graphics. We will be using this to create visualisations with a `phyloseq` object using various R packages specifically designed for community abundance data within `phyloseq` objects.

For more resources on `ggplot2` please see the [appendix](#ggplot2_appendix) of this book.

## phyloseq
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/phyloseq_logo.png", auto_pdf = TRUE)
``` 

In this book we will be working with `phyloseq` objects to preprocess  our dataset, create visualisations, and carry out statistical analyses. This is a very popular object type for community abundance datasets as it contains the abundance table, metadata, and taxonomy table in one object, optionally containing the phylogenetic tree and reference sequences if wanted/required.

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/phyloseq_input.png", auto_pdf = TRUE)
``` 

<!--chapter:end:03-R_packages.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Set-up
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/start.png", auto_pdf = TRUE)
```

Prior to any analysis we need to setup our environment in the webVNC.

## Logon instructions {#cluster}

For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent.

You will now be in a logged-in Linux VNC desktop with two terminals. 
You will see something as below (there may be only one terminal which is fine). 
If you do not see something similar please ask for assistance.

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/nsc200_logon.png", auto_pdf = TRUE)
```

If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. 
You will most likely need to use your browser's tool bar to accomplish this. 
Ensure you can see the grey borders.

These instructions will not work outside of this workshop. 
If you would like to install your own Linux OS on your desktop or laptop we would recommend Mint Linux 

The following link is a guide to install Mint Linux:  
https://linuxmint-installation-guide.readthedocs.io/en/latest/

## Mamba
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/mamba_logo.png", auto_pdf = TRUE)
```

This workshop requires a lot of packages. 
These all can be difficult to install with R. 
Instead we have used Mamba forge to install R, its packages, and Jupyter-notebook (more info below). 
To learn more about Mamba-forge and how to create your own environment please see the [appendix](#https://github.com/mamba-org/mamba).

To set-up your environment for this workshop please run the following code (you must include the full stop and space at the front of the command).

```{bash, eval=FALSE}
. usercommunity
```

You will have successfully activated the environment if you now see `(r_community)` at the start of your command prompt. 
This indicates you are now in the mamba environment called `r_community` created by the instructor.

If you are interested in the use script you can look at its contents.

```{bash, eval=FALSE}
less /usr/local/bin/usercommunity
```

__Tip:__ press `q` to quit `less`.

<!--chapter:end:04-Setup.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Jupyter
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_logo.png", auto_pdf = TRUE)
```

[`Jupyter-notebook`](https://jupyter.org/) is a nice browser based method to write, edit, and run code.
It was initally created for Python coding, but has since branched out to many other languages, such as `R`.

We are using it in this workshop for a variety of its properties:

- It is popular and well maintained.
- It is lightweight. Other heavier weight programs, such as RStudio, would struggle in our HPC due to the graphical and CPU load.
- It is interactive and displays code output. 
- It allows for easier annotation, editing, and debugging than the command line. 
- It provides a graphical interface for hanging directories and choosing files.

Before carrying out any analysis we will go through a quick tutorial of `jupyter-notebook`.

## Open Jupyter-notebook

The first step is to open `jupyter-notebook`.
Run the below command in your `(r_community)` environment.

```{bash, eval=FALSE}
jupyter-notebook
```

This will open `jupyter-notebook` in firefox. We won't need to access the linux terminal anymore. Leave it running `jupyter-notebook` and full screen your firefox so you should see something like below.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_example_1.png", auto_pdf = TRUE)
```

## Create R notebook
The next step is to create a R notebook.

1. Click on the __"New"__ button towards the top right, right of the "Upload" button.
2. From the dropdown click __"R"__ below "Python 3 (ipykernel)".

This will open up a new R notebook like below.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_example_2.png", auto_pdf = TRUE)
```

## Cells and code

Jupyter-notebook uses cells (the gray boxes) to separate code. 
This is very useful to compartmentalise our code.

There will already be one cell. Within the cell, type in the below commands.

```{r, eval=FALSE}
1+1
2-3
```

When pressing enter in cells it will create a new line.
To run all commands in a cell press `CTRL + enter`. 

Run your current cell and you should see something like below.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_example_3.png", auto_pdf = TRUE)
```

## Create new cells

You can create new cells by 2 different means.

- Press the `+` button on the tool bar (between the floppy disk `r icons::ionicons("save-outline")` and scissors `r icons::ionicons("cut")`). This will add a cell below your currently selected option.
- Click on the __`Insert`__ button and use the dropdown to add a cell above or below your currently selected cell.

__Tip:__ Hover over the toolbar icons to display a text based description of its function.

With that knowledge add a second cell below the first cell. 
Add the following code to your second cell but do not run it.

```{r, eval=FALSE}
num_1 <- 3
num_2 <- 10
```

__Tip:__ Notice there are green lines around your selected cell.

Insert a third cell and add the following code to it. Do not run the code.

```{r, eval=FALSE}
num_1 * num_2
```

## Running code

Try to run the code in the third cell. 
There should be an error as we have not created the objects `num_1` & `num_2`.
We have only written the code for these objects but not run them.

We can run all the code in a notebook starting from the first cell to the last cell.

Two methods to run all cells are:

- Click on the __"Cell"__ button.
- Click __"Run All"__ from the drop-down options.

You should then see something like the below in your notebook.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_example_4.png", auto_pdf = TRUE)
```

There is no output printed for cell 2 because we are assigning variables. However, now there is the correct output for Cell 3 as the variables were assigned before the command was run.

## Saving the file

As with RStudio and other good coding interfaces we can save our notebook.

First we should rename the file. Rename the notebook to __"jupyter_tut"__:

1. Click on the name of the notebook, currently called __"Untitled"__.
  - This is at the very top of the notebook, right of the Jupyter logo.
2. A pop-up called __"Rename Notebook"__ will appear. Change the Name to __"jupyter_tut"__.
3. Click __"Rename"__.

Now we can save the file. Two methods to save are:

- Click the floppy disk `r icons::ionicons("save-outline")` on the toolbar.
- Click on the __"File"__ button. Click __"Save and Checkpoint"__ from the dropdown options.

## Title cells with markdown

We will be using multiple notebooks in this workshop. 
However, we will also have multiple sections per notebook. 
It will therefore be useful to create header cells with markdown to create visual separation of the different sections.

To add a header cell to the top of our notebook:

- Create a new cell at the top of the notebook.
- Click on the __"Code"__ drop down and select __"Markdown"__.
  - The __"Heading"__ option no longer works.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_example_5.png", auto_pdf = TRUE)
```

- Add the following to the __"Markdown"__ cell to create a first level header.
  - Ensure you have a space between the `#` and header text ("Tutorial").
```{r, eval=FALSE}
# Tutorial
```

Great, we can now add nice headers in our notebooks. __Save__ the notebook once more before carrying on to the next section.

`r hide("Markdown")`
You won't need to know more about `Markdown` but if you are interested please see the [`Markdown` guide](https://www.markdownguide.org/basic-syntax/).
`r unhide()`

## Close the notebook

To close the notebook:

- Click on __"File"__.
- From the dropdown options click __"Close and Halt"__.

When you are back in the file explorer page you may not yet set the new file you saved.
If so, you will need to refresh the page with the Refresh button `r icons::ionicons("refresh")` towards the top right.

```{r, fig.align = 'center',out.width= '100%', echo=FALSE }
knitr::include_graphics(path = "figures/jupyter_notebook_refresh.png", auto_pdf = TRUE)
```

With that quick tutorial of `jupyter-notebook` we can start our community analysis ion the next chapter.

## Video tutorial


<div class="container">
<iframe src="https://www.youtube.com/embed/-c_6HoPMw9g" 
frameborder="0" allowfullscreen class="video"></iframe>
</div>


<!--chapter:end:05-Jupyter.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# (PART\*) Data preparation {-}

# Data prep intro
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/half_tablespoon.png", auto_pdf = TRUE)
```

In the next 3 chapters (7-9) we will learn how to:

- [Import our data.](#import_chap)
- [Summarise our `phyloseq` object.](#sum_phyloseq_chap)
- [Determine the minimum read depth for samples to be used.](#mindepthchap)

We will also use this as a chance to reinforce how to use `jupyter-notebook` with clear instructions. 
However, from chapters 10 onwards you will make more decisions on how many __"Coding"__ and __"Markdown"__ cells you want.

<!--chapter:end:06-Preprocess_part.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Import {#import_chap}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/import.png", auto_pdf = TRUE)
```

Before carrying out any analysis we first need to import our QIIME2 artifacts into a phyloseq object. Thankfully there is an R package called `qiime2R`

## Import: notebook

```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/r_script.png", auto_pdf = TRUE)
```

Prior to any coding, we will create a new directory, our analysis directory, for this workshop and create a new notebook called __"01-Import.ipynb"__ in it. We will be creating a new notebook for each chapter and numbering them so we can easily see the order of scripts.

First create a new directory.

- In the notebook file explorer, click the __"New"__ button.
- Select __"Folder"__

You will have an __"Untitled Folder"__. To rename it:

- Click on the box left of the name.
- Press the __"Rename"__ button that appeared.
- Change the name to __"R_community_workshop"__.
- Click __"Rename"__.

Click on your __"R_community_workshop"__ folder to move into it.

Next step is to create a new R notebook, rename it to __"01-Import"__, and save it.

## qiime2R

```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/qiime2r.png", auto_pdf = TRUE)
```

[`qiime2R`](https://github.com/jbisanz/qiime2R) is an R package for importing QIIME2 artifacts into a R phyloseq object. The package contains many different commands. Its function `read_qza()` can read a single artifact at a time.

The best way to import all your QIIME2 artifacts is with the `qza_to_phyloseq()` function. In your "01-Import.R" script, add the following and run the commands.

__Tip__: You can tab complete and/or copy and paste file paths within the webVNC.

```{r, eval=FALSE}
#Cell 1
#Load the package/library
library("qiime2R")

#Import data
pseq <- qiime2R::qza_to_phyloseq(
  features = "/pub14/tea/nsc206/NEOF/R_community/data/table-dada2.qza",
  tree = "/pub14/tea/nsc206/NEOF/R_community/data/rooted-tree.qza",
  taxonomy = "/pub14/tea/nsc206/NEOF/R_community/data/taxonomy.sklearn.qza",
  metadata = "/pub14/tea/nsc206/NEOF/R_community/data/media_metadata.txt"
)
```

This command creates a phyloseq object named `pseq`. It contains:

-   The ASV abundance table (`features = "table-dada2.qza"`).
-   The rooted phylogenetic tree (`tree = "rooted-tree.qza"`).
-   The taxonomic classifications of the ASVs (`taxonomy = "taxonomy.sklearn.qza"`).
-   The sample metadata (`metadata = "media_metadata.txt"`)

## Import: Summarise phyloseq
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/list_blue.png", auto_pdf = TRUE)
```

Now that we have imported the data we can extract some summary information from it.

First we will use the `microbiome` package with its `summarize_phyloseq()` function.

Create a new cell and write and run the below in it.

```{r, eval=FALSE}
#Cell 2
#Load microbiome library
library("microbiome")
#Summary of phyloseq object
microbiome::summarize_phyloseq(pseq)
```

This gives us a plethora of information:

-   The top line tells us if the data is compositional (relative abundance).
-   We get the following list of values in a paragraph and via a list.
    -   Min. number of reads: Number of reads in the sample with the lowest number of reads.
    -   Max. number of reads: Number of reads in the sample with the largest number of reads.
    -   Total number of reads: Sum of all reads across all samples.
    -   Average number of reads: Sum of all reads / number of samples.
    -   Median number of reads: Midpoint read abundance across samples.
    -   Sparsity: See expandable box further down.
    -   Any OTU sum to 1 or less?: States if there are any ASVs with a summed abundance of 1 or less across all the samples. 
    -   Number of singletons: Number of ASVs with a sum of 1 or less across all samples.
    -   Percent of OTUs that are singletons: Percentage of ASVs that only contain one read across all the samples.
    -   Number of sample variables are: Number of sample variables/groupings in our metadata.
    -   The last line shows the names of the sample variables/groupings in our metadata.

`r hide("Sparsity")`
Sparsity is a measure of the number of 0s in a table. It can be represented by the following equation:

$$
sparsity = Z/C
$$

Where:

-   Z = The number of cells that equal zero.
-   C = The total number of cells.

Let's look at an example of an abundance table with a small amount of ASVs and Samples.

|      | Sample1 | Sample2 | Sample3 |
|------|---------|---------|---------|
| ASV1 | 0       | 10      | 24      |
| ASV2 | 1       | 0       | 37      |
| ASV3 | 6       | 25      | 0       |
| ASV4 | 51      | 2       | 0       |

- This abundance table has 12 cells, 3 samples \* 4 ASVs. 
- Of these cells, 4 have an abundance of zero. 
- 4/12 = 0.3333, therefore its sparsity is 0.3333.

Sparsity can be any value from 0-1. The higher the value the more sparse it is, with a value of 1 meaning all the cells have an abundance of zero. The lower the value the less sparse it is, with a value of 0 meaning all the cells have an abundance of 1 or more.

16S data is known to be sparse so high sparsity is not unexpected. Keep in mind that lower levels of taxa (ASVs, Species, & Genera) will generally have more sparse tables that higher levels of taxa (Kingdom, Phylum, Class).
`r unhide()`

If you would like to see how the function calculates its values you can view the [source code online](https://rdrr.io/github/microbiome/microbiome/src/R/summarize_phyloseq.R).

## Save the phyloseq object
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/r_save.png", auto_pdf = TRUE)
```

When using multiple notebooks/scripts for analysis it is useful to save the R objects that will be used in different notebooks/scripts. This can be carried out with the function `save()`.

Write and run the following code in a third cell.

```{r, eval=FALSE}
#Cell 3
#Save phyloseq as file
save(pseq, file = "phyloseq.RData")
```

This saves our object `pseq` into the file `phyloseq.RData`. The suffix `.RData` is the normal convention.

We have saved our final object of the notebook. Close and halt it.

## Import: recap
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/recap.png", auto_pdf = TRUE)
```

We have imported our QIIME2 artifacts into one phyloseq object so we can analyse the data in R. This object has been saved into a ".RData" file which we will load in the next chapter.

<!--chapter:end:07-Import.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Summarise phyloseq {#sum_phyloseq_chap}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/transform.png", auto_pdf = TRUE)
```

For the next X chapters we will use one notebook. We will setup this notebook with libraries and `phyloseq` object we created in the last chapter.

After this, we will summarise the `phyloseq` object. We will investigate the read depth of samples and the number of ASVs in our dataset.

## Summarise: setup
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/setup_2.png", auto_pdf = TRUE)
```

Before starting analysis create and save a new `R` notebook called __"02-Preprocess.ipynb"__ in the analysis directory (when renaming you don't need to include the suffix).
We will use this notebook for this and the next chapter.

It is useful to add a title to the top of the notebook. 
Create a __"Markdown"__ cell and add the following first level header:

```{r, eval=FALSE}
#Preprocessing data notebook
```

The first section of our notebook will be used for setup.
This will involve loading libraries and data we need. 

For good documentation add the below second level heading to the first __"Markdown"__ cell. 

```{r, eval=FALSE}
## Setup
```

To decrease the level of a heading add another `#`.

- `# `: 1st level header.
- `## `: 2nd level header.
- `### `: 3rd level header etc...

I like to load all the libraries to be used in the notebook in this section. We will explain their uses later in this chapter.

Add the below to a new __"Code"__ cell in your notebook:

```{r, eval=FALSE}
#Libraries
library("phyloseq")
library("microbiome")
library("vegan")
```

Our last bit of set-up is to load in our abundance phyloseq object we created in the previous chapter.

```{r, eval=FALSE}
#Load the phyloseq object
load("phyloseq.RData")
```

Ensure you have run the code in this cell.

### Summarise header
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/header.png", auto_pdf = TRUE)
```

When you load in a dataset it is always useful to check it. 
We will therefore use a new section to inspect the data.

In a new __"Markdown"__ cell add the following 2nd level header.

```{r, eval=FALSE}
# Summarise the phyloseq object
```

### Summarise phyloseq
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/list_blue.png", auto_pdf = TRUE)
```

Create a second cell and add the following annotation and code. Then run the code.

```{r, eval=FALSE}
#Summary of phyloseq object
microbiome::summarize_phyloseq(pseq)
```

We ran this code in the __"01-Import.ipynb"__. You can therefore check if our new output matched the output from that notebook. This should be the case since they are the same data.

Due to the relative large amount of output to screen we'll put the next part into a new cell (third cell).

### Reads per sample
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/histogram.png", auto_pdf = TRUE)
```

In our third cell we will use the command `microbiome::readcount()` to store and display the number of reads in each sample within our `phyloseq` object (`pseq`). We can even make a quick histogram of read numbers per sample with the base `R` function `hist()`.

Write and run the below code in a third cell.

```{r, eval=FALSE}
#Number of reads per sample
reads_sample <- microbiome::readcount(pseq)
reads_sample
#Histogram
hist(reads_samples, "Histogram of read depths")
```

This information is very useful. We will use it in the next chapter to determine what our minimum read depth should be.

### ASVs per sample
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/nice_table.png", auto_pdf = TRUE)
```

The last feature we will look at before some preprocessing is the ASVs (Amplicon Feature Variants).

A useful `phyloseq` command is `otu_table()`. This allows us to extract the ASV/OTU/feature table. With this we can then carry out some other commands like looking at the total number of ASVs.

For demonstrative purposes write and run the following code in its own cell to display the ASV table.

```{r, eval=FALSE}
#Can extract ASV table (known as otu table in phyloseq)
phyloseq::otu_table(pseq)
```

With this command we will extract the number of ASVs in the original abundance table. 
We will then save this in a vector.
We will add to this vector as we create our relative abundance and rarefied abundance `phyloseq` objects. 

```{r, eval=FALSE}
#Each row is an ASV and each column is the samples
#Therefore we can get the number of ASVs in data
#Let's make a new vector with this info so we can easily keep track
num_asvs_vec <- c(nrow(phyloseq::otu_table(pseq)))
#Give the 1st element a relevant name
names(num_asvs_vec)[1] <- "abundance"
#View current vector
num_asvs_vec
```

Save this vector as a `.Rdata` object in a new cell.
This will allow us to load it in future notebooks.
Additionally, we can remove the object so it doesn't use RAM.

```{r, eval=FALSE}
#Save object as file
save(num_asvs_vec, file= "num_asvs_vec.RData")
#Remove object from environment
rm(num_asvs_vec)
```

## Summarise: recap
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/recap.png", auto_pdf = TRUE)
```

We now have an idea of some of the attributes of our dataset. We can use this knowledge to carry out some preprocessing.

<!--chapter:end:08-Summarise_phyloseq.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Minimum read depth {#mindepthchap}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/depth_diver.png", auto_pdf = TRUE)
``` 

It is good to remove samples with a very low read depth (number of sequencing reads).
However, it is not trivial to determine what an appropriate read depth is.
This value will vary from study to study.
Normally, for 16S data, a depth of at least 20K per sample is suggested. However, this is the general consensus for human microbiome data. 

In this chapter we will:

- Cover a brief intro to considertions of what is an acceptable minimum depth for your dataset.
- Reinvestigate our sample depths with a previously created histogram.
- View the depth ranges of different sample groups (site & media) with box plots.
- Create a rarefaction curve to assess if the depth of our samples have captured a good amount of biodiversity.
- Demonstrate how to filter samples by depth.

## Considerations
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/consider.png", auto_pdf = TRUE)
``` 

There are 3 main considerations to take into account for what is an appropriate depth for your dataset.

- __The biodiversity of your samples.__
  - If your sample is very biodiverse, such as the human gut microbiome, you will need a good depth (>20K per sample).
  - If your sample is less biodiverse, such as many geological environments or skin, then you will not need as much read depth.
  - Rarefaction curves are a good method to determine if your samples have enough depth. We will look at this in this chapter.
- __The biomass of your samples.__
  - Some environments are hard to extract DNA from.
  - If this is the case for you, then people will hopefully accept that this is an unfortunate reality of life and you will use what you can.
  - However, be careful of your conclusions, if you think your data doesn't have as much as it could do not make very definitive detailed claims.
- __Read depth of sample groups.__
  - It may be possible that a few samples have a much lower depth than the rest and so you may think to remove them.
  - However, these may all come from the same sample group and so you have lost all information of one group.
  - For instance, you may be comparing different geological surfaces and your rock samples have much lower read depths than the various soil samples.
  - For comparisons including the lower depth sample group (e.g. rock samples) you will need to retrain the lower depth sample.

That is a brief overview of that topic. If you are interested in more I suggest you look at papers where they have studied an environment similar to yours.

## Minimum read depth section title
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/header_l2.png", auto_pdf = TRUE)
``` 

In the next section of our `jupyter-notebook` we will investigate what the minimum read depth should be and remove sample below this.

Create a new __"Markdown"__ cell and add the following 2nd level header.

```{r, eval=FALSE}
## Minimum read depth
```

## Read depth vector and histogram
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/histogram.png", auto_pdf = TRUE)
```

We have already created a vector and histogram of the read depths across our samples. Scroll up your notebook to view these and answer the following MCQ:

```{r, echo = FALSE}
opts_p <- c("__1-8__", answer="__10,000-18,000__", "__20,000+__")
```
- What is the approximate read depth range of our dataset? `r longmcq(opts_p)`

This is a good first step but what if we want to know how the read depths vary between sample groups?

## Sample depth boxplot
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplot.png", auto_pdf = TRUE)
```

We are going to use `ggplot2` to create a couple boxplots to show the sequencing depth ranges of the different sample groups (Site & Media).

### Creating data frame for boxplots
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/metadata.png", auto_pdf = TRUE)
```

First, we need to create an object containing our sample names, Site & Media information, and the depth.
We will use this object to produce our boxplots.
Thankfully the metadata in our `phyloseq` object contains all this information except the depth.

In a new cell write and run the below code. This will extract the sample data (metadata) to a new object and display the top 6 rows fo this new object.

```{r, eval=FALSE}
#Extract sample data as a separate R object
abundance_metadf <- phyloseq::sample_data(pseq)
#View top 6 rows of metadata data frame
head(abundance_metadf)
```

The 2 new functions above are:

- `phyloseq::sample_data()`: Extracts the sample data (metadata) data frame from a `phyloseq` object.
- `head()`: Returns the first 6 parts of an R object by default.
  - It can be used for a vector, matrix, table, data frame, or function.
  - In the case of a data frame it returns the first 6 rows.

We need to add the depth information to our new data frame. 
We have extracted this previously into an object called `sample_depths`. 
However, before adding it we want to check it has the same order of samples as the rows in `abundance_metadf`.

Write and run the below script in the same cell. The code uses `head()` to view the first 6 elements of `sample_depths` and the row names of `abundance_metadf`. Then the function `idnetical()` is used to see if they are identical (`TRUE`) or not (`FALSE`).

```{r, eval=FALSE}
#Check if our vector of sample_depths has the same order as our metadata rows
head(names(sample_depths))
head(row.names(abundance_metadf))
identical(names(sample_depths),row.names(abundance_metadf))
```

The order of samples is identical so we can add the depth information to `abundance_metadf`. Carry this out in the same cell with the code below.

```{r, eval=FALSE}
#Add sample depths to metadata data frame
abundance_metadf[,"depth"] <- sample_depths
#View top 6 rows of edited metadata dataframe
head(abundance_metadf)
```

Great! We will next use this data frame to create 2 boxplots.

### Depth boxplots
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/boxplots_groups.png", auto_pdf = TRUE)
```

We are going to create 2 boxplots with `ggplot2`.
We won't go into too much detail on how the code works here, instead learning more later in this book.

The code below creates a `ggplot2` boxplot. We carry this out with 2 functions:

- `ggplot()`: This creates a `ggplot2` object, storing the information and aesthetics.
  - The first option is the data we want to use for plotting (`abundance_metadf`).
  - The second option is the aesthetics (`aes()`) to plot. In this case we want the depth column to be plotted on the y-axis (`y=depth`) and the site column to be plotted on the x-axis (`x=site`).
- `+`: We need to have a `+` at the end of the `ggplot()` function to add the next component of the plot.
- `geom_boxplot()`: This adds a layer to our `ggplot2` object. In this case it converts the `ggplot` object, which is just information, into a boxplot.

Write and run the following code in a new cell:

```{r, eval=FALSE}
#Create ggplot2 boxplot of depth by size
ggplot2::ggplot(abundance_metadf, aes=(y=depth, x=site)) +
  ggplot2::geom_boxplot()
```

```{r, echo = FALSE}
opts_p <- c(answer="__LD (Lower Durance)__", "__MD (Middle Durance)__", "__UD (Upper Durance__")
```
- Which site has the highest median depth (middle line of boxplot)? `r longmcq(opts_p)`

We will use the same code to plot the depth by media.
You can copy and paste the code changing the x aesthetic to media (`x=media`).
Carry this out in the same cell and run the code.

```{r, eval=FALSE}
#Create ggplot2 boxplot of depth by size
ggplot2::ggplot(abundance_metadf, aes=(y=depth, x=media)) +
  ggplot2::geom_boxplot()
```

```{r, echo = FALSE}
opts_p <- c(answer="__CVP__", "__ENV__", "__TSA__")
```
- Which media has the lowest median depth (middle line of boxplot)? `r longmcq(opts_p)`

From the boxplots we can see there is no drastic difference between the depths of the different sample groups. We will therefore continue and make some rarefaction curves to further assess the depth of our samples.

For more resources on `ggplot2` please see the [appendix](#ggplot2_appendix) of this book.

## Rarefaction curve {#chap9rarefaction}
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/rarefaction.png", auto_pdf = TRUE)
```

Our read depths appear a bit low, each sample has <20K reads. 
However, this might be fine for our dataset since we are using surface water samples rather than human gut microbiome samples.
Let's see how our samples look with a rarefaction curve.

__Note__: This is a quick example and we will go into more detail in the [rarefaction chapter](#rarefaction_chap).

Surprisingly, there is not a good method to produce a rarefaction curve with the `phyloseq` or `microbiome` packages. 
We will therefore use the [`vegan`](https://vegandevs.github.io/vegan/) package. 
`vegan` is an R package for community ecologists. 
It has a variety of functions but it uses normal R data frames rather than `phyloseq` objects.
We will therefore only use it for rarefaction purposes.

### ASV abundance data frame
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/nice_table.png", auto_pdf = TRUE)
```

Before creating our rarefaction curve we will extract the ASV abundance table from the `phyloseq` object with `phyloseq`'s function `otu_table()`. 
We need to transpose (`t()`) the table so it is in the correct orientation for the rarefaction function.
Additionally, we ensure it is a data frame with the function `as.data.frame()`.

Carry this out in a new cell.

```{r, eval=FALSE}
#Rarefaction curve
#Extract ASV table as data frame
asv_abund_df <- as.data.frame(t(phyloseq::otu_table(pseq)))
```

### vegan's rarecurve
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/vegan.png", auto_pdf = TRUE)
```

With this data frame we can create a rarefaction curve with `vegan`'s `rarecurve()` function.

Add the following code to the same cell and run it.

```{r, eval=FALSE}
#Rarefaction curve
vegan::rarecurve(
  x = asv_abund_df, step = 50,
  xlab = "Read depth",
  ylab = "ASVs"
)
```

__Note__: You will get a warning saying `"most observed count data have counts1, but smalled count is 2"`. This can be ignored in this case.

In essence, we are hoping that the majority of samples have plateau'd.
If the curves have flattened in relation to the y axis this indicates that most of the ASVs present in the sample have been captured.

In this case the samples have plateau'd or have gentle slopes towards the end.
With this we can be happy to continue and not remove samples by a minimum read depth.

If we saw some samples with steep curves which had low depths we could carry out some more analysis with rarefaction.
However, more rarefaction functions, analysis, and theories will be covered in the [rarefaction chapter](#rarefaction_chap).
You could use some of these at this point to help you determine your minimum read depth for your own datasets.

## Filtering by minimum read depth
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/water_filter.png", auto_pdf = TRUE)
```

What if you want to filter samples by a minimum read depth?

In that case you can use the `subset_samples()` function from `phyloseq()`.
We will use our previously created vector containing read depths (`sample_depths`) to remove sample with less than 11k reads.
We have chosen this depth as an example to remove some samples.

Write and run the below code in a new cell.
It will create a new subsetted `phyloseq` object.

```{r, eval=FALSE}
#Subset and keep samples with at least 11k reads
pseq_min11K <- phyloseq::subset_samples(pseq, reads_sample > 11000)
```

After removing samples it is also useful to remove ASVs with no abundance values.
This can occur when ASVs are only present in the samples which have been removed.

To remove these ASVs we can use two `phyloseq` functions:

- __`taxa_sums()`__: Returns a vector showing sum of all taxa in the abundance table. 
  - In our `phyloseq` object the ASVs are the taxa. 
  - ASVs have long human unfriendly names that are unique to every single ASV possible.
- __`prune_taxa()`__: This retains taxa/ASVs based on a provided vector.
  - In this case we are creating a logical vector (`TRUE`/`FALSE`) where ASVs with 0 abundance are `FALSE` and ASVs with abundance > 0 are `TRUE`.

We'll first write and run some commands with `taxa_sums()` to get some practice with it. Carry this out int he same cell as the `subset_samples()` command.

```{r, eval=FALSE}
#Abundance sums of the 1st six ASVs
head(phyloseq::taxa_sums(pseq_min11K))
#View number of ASVs in our data
length(phyloseq::taxa_sums(pseq_min11K))
```

In the same cell add the following.
This will filter out ASVs with no abundance.

```{r, eval=FALSE}
#Remove ASVs with no abundance
pseq_min11k <- phyloseq::prune_taxa(
  phyloseq_taxa_sums(pseq_min11k) > 0, pseq_min11k
)
```

Finally, summarise the contents of the `phyloseq` object. 
Add the following in the same cell and then run the code in the cell.

```{r, eval=FALSE}
#Summarise subsetted phyloseq
microbiome::summarize_phyloseq(pseq_min11K)
microbiome::readcount(pseq_min11K)
pseq_min11k
```

We can see that the data lost 26 ASVs (2551 - 2525).

Try to write your own R code in a new cell to answer the following questions:

```{r, echo = FALSE}
opts_p <- c("__4__", answer="__613__", "__42507__")
```
- What is the difference of the minimum number of reads between `pseq_min11k` and `pseq`? r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__4__", "__613__", "__42507__")
```
- How many samples were removed due to the read depth filtering? r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__4__", "__613__", answer="__42507__")
```
- What is the difference of the minimum number of reads between `pseq_min11k` and `pseq`? r longmcq(opts_p)`

`r hide("Tip")`
Combining `microbiome::readcount()` with `min()`, `length()`, and `sum()` might help.
`r unhide()`

`r hide("Code solutions + bonus")`
```{r, eval=FALSE}
#Difference of minimum read numbers
min(microbiome::readcount(pseq_min11k)) - min(microbiome::readcount(pseq))
#Number of samples lost
length(microbiome::readcount(pseq)) - length(microbiome::readcount(pseq_min11k))
#Number of reads removed
sum(microbiome::readcount(pseq)) - sum(microbiome::readcount(pseq_min11k))
#Bonus
#List the removed samples
setdiff(phyloseq::sample_names(pseq)), phyloseq::sample_names(pseq_min11k))
```
`r unhide()`

We won't actually use this subsetted file as we want to keep all the samples in this case.
Additionally, since we didn't need remove any samples we don't need to remove any ASVs as they should all have a total abundance > 0.
Therefore you can remove the `phyloseq` object in a new cell.

```{r, eval=FALSE}
#Remove subsetted phyloseq
rm(pseq_min11K)
```

Once you are finished with this notebook you can save it then close and halt it.

## Minmum read depth: Summary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_blue.png", auto_pdf = TRUE)
```

We have assessed the read depth in this chapter and decided to not remove any samples. 
This assessment included:

- Viewing a histogram of sample read depths.
- Creating boxplots to compare the sample read depths across sample groups (siet and media).
- Producing a rarefaction depth to determine if any samples did not represent a good amount of the ASVs present in the environment.

Additionally, we created a new `phyloseq` object where the samples were filtered by depth.
Ultimately we did not keep the filtered `phyloseq` object.

<!--chapter:end:09-Minimum_read_depth.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# (PART\*) Taxonomy {-}

# Taxa relative abundance
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/taxa.png", auto_pdf = TRUE)
```

In this section we are going to create taxonomy bar charts.
For this we are going to use relative abundance tables of different taxa levels; Genus, Family, & Phyla.

In this chapter we are going to create a `phyloseq` object with relative abundance values of phyla. 
We would use read depth filtered data if we wanted to use it for other downstream analyses.
But, as stated in the last chapter all our samples had sufficient depth, so we will use our original abundance `phyloseq` object.

## Taxa relative abundance: setup
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/packages.png", auto_pdf = TRUE)
```

The first steps before analysis are:

- Create a new notebook called __"3-taxonomy_barcharts"__.
  - We will use this to create our phyloseq objects and taxonomy bar charts.
- Add a markdown cell with the first level header: `# Taxonomy bar charts`.
- Add the below to a code cell to load in the `phyloseq` object and libraries.
```{r, eval=FALSE}
#Libraries
library("phyloseq")
library("microbiome")
library("IRdisplay")
#Load phyloseq object
load("phyloseq.RData")
```

From now on you will get less instructions on your notebook structure. 
Please create your own coding and markdown cells where you think appropriate.

## Relative abundance transformation
```{r, fig.align = 'center',out.width= '40%', echo=FALSE }
knitr::include_graphics(path = "figures/count_to_percent.png", auto_pdf = TRUE)
```

Now that we have the data loaded we can create a new `phyloseq` object by transforming the abundance values to relative abundances.

This is carried out with the `microbiome` function `transform()`. With it we transform the ASV abundance table within to a "compositional" table (relative abundance). 

Run the below command in an appropriate place in your notebook:

```{r, eval=FALSE}
#Transform abundance table to a relative abundance (compositional) table
pseq_relabund <- microbiome::transform(pseq, "compositional")
```

As always it is good to check the contents of the new ASV table.

```{r, eval=FALSE}
#Summarise and check sample counts which should each amount to 1
microbiome::summarize_phyloseq(pseq_relabund)
microbiome::readcount(pseq_relabund)
```

You will notice the read count for each sample is __1__. This abundance table contains fractional relative abundances for each ASV. This fraction is relative to the total abundance within each sample. Therefore, all the fractional relative abundance values of ASVs in one sample total 1.

We will use this to produce all our different taxa tables.

## Aggregate taxa
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/aggregate_taxa.png", auto_pdf = TRUE)
```

To produce a taxa table we can use the `microbiome` function `aggregate_taxa()`.

Run the below command to produce a phylum based `phyloseq` object.

__Reminder__: You may want a markdown cell to create a 2nd level header for this phylum section.

```{r, eval = FALSE}
#Check head of tax_table
#This will tell us the taxa level names on the column names
head(tax_table(pseq_relabund))
#Phylum phyloseq
phylum_pseq <- microbiome::aggregate_taxa(pseq_relabund, "Phylum", verbose = FALSE)
```

Let's check our phyla `phyloseq`.

```{r, eval=FALSE}
#Head of phylum relative abundance table
head(phyloseq::otu_table(phylum_pseq))
#Number of phyla
paste0("Number of phyla: ", nrow(phyloseq::otu_table(phylum_pseq)))
#Summarise
microbiome::summarize_phyloseq(phylum_pseq)
microbiome::readcount(phylum_pseq)
```

## Taxa Relative abundance: summary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_blue.png", auto_pdf = TRUE)
```

We have produced a `phyloseq` object containing a Phylum relative abundance table. Next, we will create a taxonomy bar chart with this.

<!--chapter:end:10-Relative_abundance.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Taxa plots
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/owl_eyes.png", auto_pdf = TRUE)
```

Now that we have our Genus relative abundance `phyloseq` we can create a bar chart.

## Simple bar chart
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/bar_chart.png", auto_pdf = TRUE)
```

To create a simple genus bar chart we can use the following code.

```{r, eval=FALSE}
#Simple bar chart
phylum_bar <- microbiome::plot_composition(phylum_pseq)
phylum_bar
```

We have created and saved a `ggplot` object called `phylum_bar`. 
We then viewed it by calling the object.
This is a good start but the plot is a bit hard to read.

### Save ggplot as png
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/png_file.png", auto_pdf = TRUE)
``` 

It can be a good idea to save a `ggplot` object as a file with `ggsave()`.
This allows you to select the size and resolution (`dpi`) of the image.

```{r, eval=FALSE}
#Save ggplot object as png file
ggsave(filename = "./phylum_relabund_simple.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
```

### Display png
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/display_png.png", auto_pdf = TRUE)
``` 

We can use the R package [`IRdisplay`](https://github.com/IRkernel/IRdisplay) to display plots from files in `jupyter-notebook`.

Use the function `display_png()` to display our bar chart.

```{r, eval=FALSE}
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./phylum_relabund_simple.png")
```

### Editing the plot
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/plus_sign.png", auto_pdf = TRUE)
``` 

Components can be added to `ggplot2` objects to edit the plot.
They are added with the `+` symbol.

Go to the cell where you created your plot and add components so it looks like the below:

```{r, eval=FALSE}
#Simple bar chart
phylum_bar <- microbiome::plot_composition(phylum_pseq) +
  #Change/add the x and y labels
  xlab("Sample") + ylab("Relative abundance") +
  #Add a title to the plot
  ggtitle("Phylum relative abundance bar chart")
```

Now save and display the plot.

## Taxa heatmap
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/heatmap.png", auto_pdf = TRUE)
``` 

Our bar chart looks quite nice but for displaying all taxa present it may be better to use a heatmap.
Use the below code to produce and visualise a heatmap.

__Tip__: I encourage you to copy and paste your previous bar chart code to edit.

```{r, eval=FALSE}
#Produce heatmap ggplot
phylum_heatmap <- microbiome::plot_composition(phylum_pseq, plot.type = "heatmap") +
  xlab("Phylum") + ylab("Sample") +
  ggtitle("Phylum relative abundance heatmap")
#Save ggplot object as png file
ggsave(filename = "./phylum_relabund_heatmap.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./phylum_relabund_heatmap.png")
```

With the heatmap it is much easier to tell what the relative abundances of different phyla are.

```{r, echo = FALSE}
opts_p <- c("__Chloroflexi__", "__Firmicutes__", answer="__Proteobacteria__")
```
- What is the most abundant phyla across the samples? `r longmcq(opts_p)`

## Aggregate rare taxa{#aggregateraretaxa}
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/origami_rhino.png", auto_pdf = TRUE)
``` 

From our bar chart and our heatmap we can see that there are a few high abundance phyla (Actinobacteria, Bacteroidetes, Firmicutes, & Proteobacteria) and many low abundance phyla.

To make a better visualisation we will aggregate the rare phyla.
This will give us less phyla to plot so we don't need to use so many colours.

To carry this out we will use the `microbiome` function `aggregate_rare()`.
The function has three main options:

- __`level =`__: Taxa level to aggregate table.
- __`detection =`__: Detection threshold (see below).
- __`prevalence =`__: Prevalence threshold (see below).

The function will aggregate taxa to our specified level. 
Whilst doing this it will aggregate the rare taxa of that level to one group called "Other".
Rare taxa are specified via the __detection__ and __prevalence__ thresholds.
Any taxa with an abundance >= to the __detection__ threshold in a number of samples >= to the __prevalence__ threshold will be kept.
The taxa which don't reach these thresholds will be classified as rare and aggregated into "Other".

In the below example we are aggregating the rare taxa with our ASV relative abundance `phyloseq` object.
Any phyla with a relative abundance >= to 0.01 (__detection__) in at least 5% (5/100) of the samples will not be classified as rare.

More info on [Prevalence & detection](https://microbiome.github.io/OMA/quality-control.html#prevalence).

__Note__: The __detection__ and __prevalence__ thresholds can be given as numbers (1, 2, 1000 etc.), or percentage values (5/100, 50/100, etc.).

Aggregate the relative abundance table to phyla with the rare thresholds:

```{r, eval = FALSE}
#Aggregate rare phyla
phylum_rareaggregate_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Phylum",
  detection = 0.01, prevalence = 5/100
)
```

We will plot this as a new taxonomy bar chart with some additions:

```{r, eval = FALSE}
#Plot
#Add otu.sort to sort phyla by abundance (highest to lowest)
phylum_bar <- 
  microbiome::plot_composition(phylum_rareaggregate_pseq, 
                               otu.sort ="abundance") +
  xlab("Sample") + ylab("Relative abundance") +
  ggtitle("Phylum relative abundance bar chart") +
  #Change colours of Phylum to that of the "Paired" palette from colour brewer
  scale_fill_brewer("Phylum", palette = "Paired")
#Save ggplot object as png
ggsave(filename = "./phylum_relabund_rareaggregate.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display plot
IRdisplay::display_png(file="./phylum_relabund_rareaggregate.png")
```

`r hide("Colour brewer palettes")`
```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/colour_brewer_palettes.png", auto_pdf = TRUE)
```
[Source](https://r-graph-gallery.com/38-rcolorbrewers-palettes.html)
`r unhide()`

That is a very nice and clean bar chart.
We can quite easily see that there are 7 main phyla (excluding other).
Additionally, it seems that the biggest difference between samples is due to the media used.

## Plot by media
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/petri.png", auto_pdf = TRUE)
``` 

One of the many great advantages of `ggplot2` is that you can create plots tailored to your metadata.
As an example we will create another taxonomy bar chart but have one bar for each media site.

We'll use a very similar code as the above bar chart but add the `microbiome::plot_composition` option `average_by =`.
With this we will average the rare aggregated relative abundance values by the four different media.

```{r, eval=FALSE}
#Plot by media
phylum_media_bar <- 
  microbiome::plot_composition(phylum_rareaggregate_pseq, 
                               otu.sort ="abundance",
                               average_by = "media") +
  xlab("Sample") + ylab("Relative abundance") +
  ggtitle("Phylum relative abundance bar chart by media") +
  scale_fill_brewer("Phylum", palette = "Paired")
#Save ggplot object as png
ggsave(filename = "./phylum_relabund_media_rareaggregate.png", plot = phylum_media_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display plot
IRdisplay::display_png(file="./phylum_relabund_media_rareaggregate.png")
```

Now we get a good picture of which medias have the highest and lowest phlya diversity. 
The Environmental samples (ENV) definitely have the highest diversity with clear presence of all phyla.

```{r, echo = FALSE}
opts_p <- c(answer="__CVP__", "__KBC__", "__TSA__")
```
Which media has the highest relative abundance of _Protoebacteria_ and the lowest phyla diversity (excluding ENV)? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__CVP__", "__KBC__", answer="__TSA__")
```
Which media has the lowest relative abundance of _Protoebacteria_ and the highest phyla diversity (excluding ENV)? `r longmcq(opts_p)`

Later in this book we will investigate diversity more thoroughly with alpha and beta diversity visualisation and statistics.

## Plot by site and media
```{r, fig.align = 'center',out.width= '35%', echo=FALSE }
knitr::include_graphics(path = "figures/site_and_media.png", auto_pdf = TRUE)
``` 

__Task__: In the `sample_data` there is a column called `site.media`.
Use this column to create a phyla bar chart averaged by site and media.
Please make a good effort at the task before look at the solution in the below box.

`r hide("Site and media bar chart solution")`
```{r, eval=FALSE}
#Plot by site and media
phylum_site_media_bar <- 
  microbiome::plot_composition(phylum_rareaggregate_pseq, 
                               otu.sort ="abundance",
                               average_by = "site.media") +
  xlab("Sample") + ylab("Relative abundance") +
  ggtitle("Phylum relative abundance bar chart by site & media") +
  scale_fill_brewer("Phylum", palette = "Paired")
#Save ggplot object as png
ggsave(filename = "./phylum_relabund_site_media_rareaggregate.png", plot = phylum_site_media_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display plot
IRdisplay::display_png(file="./phylum_relabund_site_media_rareaggregate.png")
```
`r unhide()`

## Taxa plots: summary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_purple.png", auto_pdf = TRUE)
``` 

In this chapter we have:

- Created taxa bar charts with `microbiome` and `ggplot2`.
- Saved `ggplot2` plots as `pngs` with `ggsave()`.
- Displayed `pngs` with `IRdisplay::display_png()`.
- Produced taxa heatmaps.
- Aggregated rare taxa based on detection and prevalence.
- Grouped bars in bar charts by metadata groups.

We will reinforce this by producing Family and Genus based plots in the next chapter.

<!--chapter:end:11-Taxa_plots.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Family & Genus plots
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/plots.png", auto_pdf = TRUE)
```

In this chapter you will:

- Create Family plots by following example code.
- Be tasked to create Genus plots with little instruction.

I highly encourage you to copy previous code and edit it.
It is a major time saver.
However, it can be easy to overlook some edits.
It is a good idea to double check your edited code to ensure you have changed the relevant options, and object & file names.

## Family taxa plots
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/family.png", auto_pdf = TRUE)
```

This part will show you a nice workflow for creating some family based taxa plots.
Run this at the bottom of your "3-taxonomy_barchart.ipynb" notebook.

### Aggregate families
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/aggregate_taxa.png", auto_pdf = TRUE)
```

First we will create a `phyloseq` object by aggregating the families from the relative abundance `phyloseq` object.
Let us also then check the family `phyloseq` object.

```{r, eval = FALSE}
#Family phyloseq
family_pseq <- microbiome::aggregate_taxa(pseq_relabund, "Family", verbose = FALSE)
#Head of phylum relative abundance table
head(phyloseq::otu_table(family_pseq))
#Number of families
paste0("Number of families: ", nrow(phyloseq::otu_table(family_pseq)))
#Summarise
microbiome::summarize_phyloseq(family_pseq)
microbiome::readcount(family_pseq)
```

We have 112 families. Quite a bit but hopefully they will all fit into a heatmap.

### Family heatmap
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/heat_topology.png", auto_pdf = TRUE)
```

We will create a heatmap as before with one added `ggplot2` component.
As there are a lot of Families (112) and fewer samples (36) it will be easier to view if we have the families on the y-axis.
By default `microbiome::plot_composition()` will plot the taxa/families on the x-axis.
Thankfully we can use the `ggplot2()` function/component `coord_flip()` to flip/swap the x and y axes.

__Note__: The `xlab()` and `ylab()` are specified the before this flipping.
E.g. `xlab()` is set to "Family" which will appear on the y axis because of the flip.

```{r, eval=FALSE}
#Family heatmap
family_heatmap <- microbiome::plot_composition(family_pseq, plot.type = "heatmap") +
  xlab("Family") + ylab("Sample") +
  ggtitle("Family relative abundance heatmap") +
  #Flip the x and y axes
  coord_flip()
#Save ggplot object as png file
ggsave(filename = "./family_relabund_heatmap.png", plot = family_heatmap,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./phylum_relabund_heatmap.png")
```

The plot is quite large.
You can right click on the image and click "Open Image in New Tab" to view the whole image in a new tab.

With this heatmap we can see that the KBC and TSA samples have a high relative abundance of _Pseudomonadaceae_ whilst the TSA samples have a high relative abundance of _Aeromonadaceae_.
Additionally, we can see that a lot of families have relatively low relative abundances.

Once you are finished looking at the plot the tab containing the plot.
This will help to keep the used resources low on the cluster.
Next we'll carry out our rare aggregation and produce some bar charts.

### Family rare aggregation
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/elephant_origami.png", auto_pdf = TRUE)
```

To aggregate our rare families we need to choose a suitable [detection and prevalence threshold](#aggregateraretaxa).
Generally, this is a process of trial and error trying to get a total of 12 taxa.
Twelve is a good number as it is the total number of colours in the Paired palette from Colour brewer.
You may need more in your own analysis so it is not a hard limit.

Therefore, lets try out various thresholds and see how many families we get.
To get a good idea where to start we can get a summary of the mean relative abundance values of the families.

```{r, eval=FALSE}
#Summary of row means (families) from the family otu table
summary(rowMeans(phyloseq::otu_table(family_pseq)))
```

We have a lot of families so we will want to remove a good amount of them.
For our first attempt at rare aggregation we will use a value near the 3rd Quartile (0.0021601).
This will hopefully remove at least 3/4 of the families.

We'll set up the code a bit differently so we can easily copy and paste it to try out various other values of detection and threshold.

```{r, eval = FALSE}
#Tests
#1
d <- 0.002
p <- 5/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of families = ", nrow(phyloseq::otu_table(test_pseq)))
```

That gives us 56 families which is too high for a nice visualisation. We'll therefore try a bunch of trial and error to get 12 families after aggregation.

```{r, eval = FALSE}
#2 Increase prevalence threshold
d <- 0.002
p <- 10/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of families = ", nrow(phyloseq::otu_table(test_pseq)))
#3 Increase detection threshold
d <- 0.005
p <- 10/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of families = ", nrow(phyloseq::otu_table(test_pseq)))
#4 Increase detection threshold
d <- 0.02
p <- 10/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of families = ", nrow(phyloseq::otu_table(test_pseq)))
#5 Increase prevalence threshold
d <- 0.02
p <- 20/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of families = ", nrow(phyloseq::otu_table(test_pseq)))
#Remove unwanted test_pseq
rm(test_pseq)
```

Super! 
A Detection threshold of 0.02 and a prevalence threshold of 20/100 gives us 12 families.
We'll now create a new `phyloseq` object using this info in a new cell.

```{r, eval = FALSE}
#Aggregate families phyla
family_rareaggregate_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Family",
  detection = 0.02, prevalence = 20/100
)
```

Choosing a good detection and prevalence threshold is quite difficult.
It takes a lot of trial and practice and I find the thresholds to not be very intuitive to understand.
One piece of advise is to only change one threshold at a time during your trial and errors.

### Family bar chart
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/chocolate_bar.png", auto_pdf = TRUE)
```

With our family rare aggregated `phyloseq` object we'll create a bar chart.

```{r, eval=FALSE}
#Plot
family_bar <- 
  microbiome::plot_composition(family_rareaggregate_pseq,
                               #otu.sort to sort family by abundance
                               otu.sort = "abundance", group_by = "media") +
  xlab("Sample") + ylab("Relative abundance") +
  ggtitle("Family relative abundance bar chart") +
  #Change colours of families to that of the "Paired" palette from colour brewer
  scale_fill_brewer("Family", palette = "Paired")
#Save ggplot object as png
ggsave(filename = "./family_relabund_rareaggregate.png", plot = family_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./family_relabund_rareaggregate.png")
```

Brilliant, we are no finished with the Family taxa plots. Onto something harder.

## Genus taxa plots
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/ginger.png", auto_pdf = TRUE)
```

In this section you are running your own analysis for the Genus information in the "3-taxonomy_barchart.ipynb" notebook.
Carry out the following tasks with the relative abundance `phyloseq` object (`pseq_relabund`):

- Create an aggregated genus `phyloseq` object and summarise it (no rare aggregation).
- Create a heatmap of the genera relative abundances.
- Carry out genus rare aggregation so the resulting `phyloseq` object only contains 12 genera.
- Use the rare aggregated `phyloseq` object to create a bar chart grouped by __media__.

In essence you are going through the workflow for the family data but for genus instead.
Again, I encourage you to copy, paste, and edit previous code.
You will most likely need to change names of objects and also change various options.

### Genus taxa plots solutions
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/ginger_solutions.png", auto_pdf = TRUE)
```

Please give the task a good try before looking at the solutions in the expandable boxes.
However, if you are really stuck or want to compare your code to mine please have a look.
Please, remember that there are many ways to do the same thing.
If your code is different but it works and you understand it then that is fine.

`r hide("Aggregate genus and summarise")`
```{r, eval = FALSE}
#Genus phyloseq
genus_pseq <- microbiome::aggregate_taxa(pseq_relabund, "Genus", verbose = FALSE)
#Head of genus relative abundance table
head(phyloseq::otu_table(genus_pseq))
#Number of genera
paste0("Number of families: ", nrow(phyloseq::otu_table(genus_pseq)))
#Summarise
microbiome::summarize_phyloseq(genus_pseq)
microbiome::readcount(genus_pseq)
```
`r unhide()`

`r hide("Heatmap")`
```{r, eval=FALSE}
#Genus heatmap
genus_heatmap <- microbiome::plot_composition(genus_pseq, plot.type = "heatmap") +
  xlab("Genus") + ylab("Sample") +
  ggtitle("Genus relative abundance heatmap") +
  #Flip the x and y axes
  coord_flip()
#Save ggplot object as png file
ggsave(filename = "./genus_relabund_heatmap.png", plot = genus_heatmap,
       device = "png", dpi = 300, units = "mm", height = 450, width = 300)
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./genus_relabund_heatmap.png")
```
`r unhide()`

`r hide("Aggregate rare genus")`
```{r, eval=FALSE}
#Summary of row means (families) from the family otu table
summary(rowMeans(phyloseq::otu_table(genus_pseq)))
```
```{r, eval = FALSE}
#Tests
#1
d <- 0.001
p <- 5/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of genera = ", nrow(phyloseq::otu_table(test_pseq)))
#2
d <- 0.01
p <- 5/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of genera = ", nrow(phyloseq::otu_table(test_pseq)))
#3
d <- 0.01
p <- 20/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of genera = ", nrow(phyloseq::otu_table(test_pseq)))
#4
d <- 0.005
p <- 20/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of genera = ", nrow(phyloseq::otu_table(test_pseq)))
#1
d <- 0.006
p <- 20/100
test_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = d, prevalence = p
)
paste0("Detection = ", d, ", Prevalence = ", p,
       ", Number of genera = ", nrow(phyloseq::otu_table(test_pseq)))

#Remove unwanted test_pseq
rm(test_pseq)
```
```{r, eval = FALSE}
#Aggregate genus phyla
genus_rareaggregate_pseq <- microbiome::aggregate_rare(
  pseq_relabund, level = "Genus",
  detection = 0.006, prevalence = 20/100
)
```
`r unhide()`

`r hide("Bar chart")`
```{r, eval=FALSE}
#Plot
genus_bar <- 
  microbiome::plot_composition(genus_rareaggregate_pseq,
                               #otu.sort to sort genera by abundance
                               otu.sort = "abundance", group_by = "media") +
  xlab("Sample") + ylab("Relative abundance") +
  ggtitle("Genus relative abundance bar chart") +
  #Change colours of genera to that of the "Paired" palette from colour brewer
  scale_fill_brewer("Genus", palette = "Paired")
#Save ggplot object as png
ggsave(filename = "./genus_relabund_rareaggregate.png", plot = family_bar,
       device = "png", dpi = 300, units = "mm", height = 200, width = 300)
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./genus_relabund_rareaggregate.png")
```
`r unhide()`

Once you are happy you can __Close and Halt__ the notebook.

<!--chapter:end:12-Family_and_Genus_taxa.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# (PART\*) Diversity analysis {-}

# Diversity analysis intro
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/diversity.png", auto_pdf = TRUE)
```

In the next X chapters we will carry out diversity analyses. This will include calculating and visualising diversity values plus carrying out the associated statistics.

In the chapters we will carry out:

- [Rarefaction of our ASV table.](#rarefaction_chap)
- [Alpha diversity of the rarefied data.](#alpha_chap)
- Beta diversity of the rarefied data.
- Biomarker detection.

During this we will attempt to answer our questions from [Chapter 2](#summary-questions):

- How does the bacterial communities change across the anthropisation gradient?
- Is there a difference in the replicates of one site and media combination. I.e. do any of the media produce inconsistent profiles.
- Is there more difference between the sites or the media used?
- Do any of the media produce a similar taxonomic profile to the environmental sample?

<!--chapter:end:13-Diversity_analysis.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Rarefaction {#rarefaction_chap}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/whale.png", auto_pdf = TRUE)
```

We are going to create a rarefied abundance table in this chapter. 
This can be a controversial topic.
Please make your own decision if you want to do this or not in your own analysis.

## Rarefaction: setup
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/library_1.png", auto_pdf = TRUE)
```

We will use a new notebook called **"4-rarefaction.ipynb"**. 
Add the following to the top of this new notebook to load the required libraries/packages and data.

```{r, eval=FALSE}
#Libraries
library("phyloseq")
library("microbiome")
library("vegan")
library("IRdisplay")
#Load phyloseq object
load("phyloseq.RData")
#Load ASV count vector
load("num_asvs_vec.RData")
```

Ensure you add markdown and code cells to this notebook to give yourself
a good structure.

## Rarefaction curve
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/rarefaction.png", auto_pdf = TRUE)
```

Prior to rarefying our data we need to determine the depth we want to
use. We can carry this out with a rarefaction curve.

A rarefaction curve is produced by randomly sampling the sequences in a
sample (without replacement). The rarefaction curve extracts
the number of unique ASVs in the first N sequences of each sample. 
N is equal to the step size which
we will set as 50 (`step = 50`). 
This is followed by the number of unique ASVs found in 2N, then 3N etc.

The plot will show the number of total unique ASVs it has found
against the depth it has currently sampled. Therefore, after 10 steps it
will be at a depth of 500 on the x-axis (50 \* 10) and it will show how
many unique ASVs it has currently discovered from all 10 samplings.

### Bird analogy
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/ibyster.png", auto_pdf = TRUE)
```

You are cataloguing the bird diversity (ASV diversity) in three forests/woods
in Hampshire (3 samples of our abundance table). You record your
findings over a week for each forest. Your record on the cumulative
amount of unique species you find over the 3 separate weeks are in the
table below:

| Day | New Forest (93900 acres) | Telegraph woods (50 acres) | Old Lords wood (4.67 acres) |
|---------------|------------------|--------------------|--------------------|
| 1   | 12                       | 7                          | 8                           |
| 2   | 21                       | 12                         | 10                          |
| 3   | 32                       | 16                         | 11                          |
| 4   | 40                       | 21                         | 13                          |
| 5   | 49                       | 23                         | 13                          |
| 6   | 60                       | 24                         | 13                          |
| 7   | 65                       | 25                         | 13                          |

: Cumulative bird species found in Hampshire forests/woods over a week

This can then be plotted in a rarefaction plot like below.

```{r, echo=FALSE, warning=FALSE, fig.align = 'center' }
library("vegan")
New_forest <- c(0,12,21,32,40,49,60,65)
Telegraph_woods <- c(0,7,12,16,21,23,24,25)
Old_lords_wood <- c(0,8,10,11,13,13,13,13)
time_points <- 0:7
plot(x = time_points, y = New_forest, col = "#D81B60", type = "l",
     xlab = "Bird species", ylab = "Bird species", lwd = 5)
lines(x = time_points, y = Telegraph_woods, col = "#1E88E5", lwd = 5)
lines(x = time_points, y = Old_lords_wood, col = "#004D40", lwd = 5)
```

In this case we can be fairly confident that seven days is enough to find all the birds we can in the Old Lords wood (green). 
I.e. the sampling depth is enough. 
Just like bird watching, it is very hard to find all the species present in a sample with metabarcoding or shotgun metagenomics. 
This can be caused by our barcodes not picking up all species, our sampling wasn't perfect, some species are very rare, or errors that DNA sequencing introduces.

A week seems like a good amount for sampling the Telegraph woods (Blue) but it is possible that some more species have not been recorded. 

Strikingly, a week does not appear to be enough time for the New Forest (red). The amount of new species decreased to 5 on day 7 but the curve has not yet plateau'd.

This hopefully helps you understand why rarefaction curves are a useful measure of how well we have captured the diversity of samples at different depths. 

### Rarefaction curve: simple plot
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/crayon.png", auto_pdf = TRUE)
```

We'll use `vegan` to create our rarefaction curve like we did in
[Chapter 9](#chap9rarefaction).

```{r, eval=FALSE}
#Extract ASV table as data frame
asv_abund_df <- as.data.frame(t(phyloseq::otu_table(pseq)))
#Rarefaction curve
vegan::rarecurve(
  x = asv_abund_df, step = 50,
  xlab = "Read depth",
  ylab = "ASVs"
)
```

### Rarefaction curve: better plot
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/palette_brush.png", auto_pdf = TRUE)
```

It is a useful plot but we can make it bigger and better! We will do
that with the following additions:

-   Saving it as a `.png` file with the functions `png()` and
    `dev.off()`.
-   Adding extra options to `vegan::rarecurve()`:
    -   `lwd`: Sets the line width of the plot.
    -   `label`: Turn the sample labels on (`T`) or off (`F`).
    -   `sample`: Draws a vertical line at the specified depth.
        Additionally, draws a horizontal line for each sample showing
        how many ASVs were discovered at the sampling depth.

We will initially use our minimum sample depth as our rarefaction/sampling depth.
This is a good idea if it seems like a good amount as it will allow us to keep all our samples after rarefaction.
Any samples with a lower depth than are final rarefaction size will be removed.

```{r, eval=FALSE}
#Improved plot saved as file
png(filename = "./rarefaction_plot.png", res = 300,
    units = "mm", height = 200, width = 300)
#Plot
vegan::rarecurve(
  x = asv_abund_df, step = 50,
  xlab = "Read depth", ylab = "ASVs", lwd=1, label = F,
  sample = min(microbiome::readcount(pseq))
)
dev.off()
#Display the plot in jupyter notebook
IRdisplay::display_png(file="./rarefaction_plot.png")
```

From this plot we can see that most of the samples have plateu'd quite nicely at the minimum depth.
This indicates that this is a good sampling depth, i.e. depth to be chosen for rarefying the data.
The grey horizontal lines help show how many more ASVs are found in a sample after the chosen sampling depth.
This can be seen in the sample with the highest number of ASVs where 5-20 more ASVs are discovered with its final depth of ~16,000.

## Rarefaction slope
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/hill_landscape.png", auto_pdf = TRUE)
```

We can calculate the slope of each sample at our specified sampling depth.
A slope of 0 shows a flat horizontal line (what we want).
A slope of 1 shows a flat vertical line (not what we want).

To get the slope of each sample we will use `vegan::rareslope()`.

```{r, eval=FALSE}
#Rarefaction slopes
rarefaction_slopes <- vegan::rareslope(
  x = asv_abund_df, sample = min(microbiome::readcount(pseq))
)
#View slopes from lowest to highest value
sort(rarefaction_slopes)
#Summary of slopes
summary(rarefaction_slopes)
#Histogram of slopes
hist(rarefaction_slopes)
```

With the calculated slopes attempt the following questions:

```{r, echo = FALSE}
opts_p <- c("__UD_ENV_rep2__", answer="__MD_ENV_rep3__", "__LD_CVP_rep1__")
```
1. Which sample has the largest slope value? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__UD_ENV_rep2__", "__MD_ENV_rep3__", answer="__LD_CVP_rep1__")
```
2. Which sample has the lowest slope value? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__Environmental__", "__Media__")
```
3. Which samples have larger slope values; the environmental samples or media samples? `r longmcq(opts_p)`

Overall the slopes values are low (<0.01).
It is noticeable that the environmental samples have higher slopes than the media samples.
Biologically, this makes sense as there is no bias being introduced by media.

## Rarefy data
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/pangolin.png", auto_pdf = TRUE)
```

The minimum sample depth appears to be a good choice for rarefying.
It keeps all the samples and at this depth the samples have a very good coverage of the ASVs present in the data.
This is represented by the good plateauing in the rarefaction plot and the low valued slopes (<0.01).
In your own analyses you may need to balance the loss of samples with the loss of depth.

With that decision we will rarefy our data to the minimum depth.

```{r, eval=FALSE}
#Rarefy to minimum depth
pseq_rarefy <- phyloseq::rarefy_even_depth(
  pseq, sample.size = min(microbiome::readcount(pseq)),
  rngseed = 1000
  )
```

The options we provided to the function `rarefy_even_depth` were:

- __`pseq`__: The `phyloseq` object to rarefy.
- __`sample.size =`__: The sampling depth to rarefy to.
- __`rngseed`__: This is the seed used for random subsampling.
  - If you rarefy the data again with the same seed it will extract the same data.
  - This is useful so you and others can replicate your work.
  - Additionally, it means you will get the same output as me (the writer) so you can accurately compare your findings to mine.

As always, it is useful to check our data.

```{r, eval=FALSE}
#Summarise and check sample counts which should each amount to 10433 (min depth)
microbiome::summarize_phyloseq(pseq_rarefy)
microbiome::readcount(pseq_rarefy)
#ASV counts
#Add relative abundance ASV count
num_asvs_vec["rarefied"] <- nrow(phyloseq::otu_table(pseq_rarefy))
num_asvs_vec
```

```{r, eval=FALSE}
#ASV counts
#Add relative abundance ASV count, read in at start of notebook
num_asvs_vec["rarefied"] <- nrow(phyloseq::otu_table(pseq_rarefy))
num_asvs_vec
```

With this we can see that all our samples have the correct depth (10,433) and very few ASVs have been lost (2551-2498 = 53).
I would definetly be happy with this outcome.

Once you have viewed the outputs save your `phyloseq` object and ASV count vector.

```{r, eval=FALSE}
#Phyloseq save
save(pseq_rarefy, file ="phyloseq_rarefied.RData")
#ASV count save
save(num_asvs_vec, file="num_asvs_vec.v2.RData")
```

Now you can close and halt the notebook.

## Rarefaction: summary
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/sum_orange.png", auto_pdf = TRUE)
```

In this chapter we:

- Determined the sampling depth to rarefy to with rarefaction curves and slopes.
- Rarefied our samples to the minimum read depth. This retained all our samples whilst using a good depth.

We now have an abundance table, relative abundance table, and rarefied abundance table. We will use these to carry out some analyses.

<!--chapter:end:14-Rarefaction.Rmd-->

```{r include=FALSE, cache=FALSE}
suppressPackageStartupMessages({
  library(webexercises)
})

knitr::knit_hooks$set(webex.hide = function(before, options, envir) {
  if (before) {
    if (is.character(options$webex.hide)) {
      hide(options$webex.hide)
    } else {
      hide()
    }
  } else {
    unhide()
  }
})
```
# Alpha diversity {#alpha_chap}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/whale.png", auto_pdf = TRUE)
```

In this chapter we are going to produce alpha diversity plots and statistics with our rarefied data.
Alpha diversity is carried out by producing a metric for each sample.
These metrics are primarily interested in the evenness or diversity of a sample.

Generally, these metrics are carried out on the ASV data to see the most fine grain differences between samples.
However, you can also use different taxa levels which we will show later on.
This can be useful if there is too much difference in the ASVs from sample to sample or you can only accurately classify sequences to a high level taxonomy (such as with `KRAKEN2` output).

Once we have a value for each sample they can be used to compare samples and sample groups.
Box plots are used for visualisation.
Statistics are used to determine if there is a significant difference between groups.

We'll start out by producing a basic box plot and statistics.
Next we'll improve the plot with some extra R packages.
With these tools we will compare the metrics across the various metadata fields we have.

## Alpha: setup
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/library_1.png", auto_pdf = TRUE)
```

We will use a new notebook called **"5-alpha_diveristy.ipynb"**. 
Add the following to the top of this new notebook to load the required libraries/packages and data.

```{r, eval=FALSE}
#Libraries
library("phyloseq")
library("microbiome")
library("IRdisplay")
#Load phyloseq object
load("phyloseq_rarefied.RData")
```

Reminder to use markdown and code cells in the notebook.

## Alpha: simple plot

The first step is to calculate and plot the alpha diveristy metrics based on the ASV data.
Thankfully, the command `phyloseq::plot_richness()` will do both of these.
Try it out.

```{r, eval = FALSE}
phyloseq::plot_richness(physeq = pseq_rarefy)
```

The resulting plot is pretty good but unreadable. 
We can do 3 major things to make the contents easier to read.

### Metric choice

We can choose certain alpha diversity metrics to plot. 
Currently it is showing 7 metrics (Observed, Chao1 etc.).
I like to use:

- __Observed__: This is the number of observed features (ASVs, Genera, etc) in each sample.
- __Chao1__: This is an estimate number of the total number of features in each sample.
- __Shannon__: A measure of diversity where a higher number means higher diversity. Shannon's index accounts for both abundance and evenness of the features present.

We'll choose these metrics with the `measures = ` option.
Either make a new code block with new code or you can edit and run the previous code you wrote.

```{r , eval = FALSE}
phyloseq::plot_richness(physeq = pseq_rarefy, measures = c("Observed","Chao1","Shannon")
```

To see which measures are available you can see the help page of `phyloseq::plot_richness()`.

For a list and full description of the metrics please see the APPENDIX

LINK NEEDS TO BE ADDED ABOVE WHEN APPENDIX MADE.

```{r, eval=FALSE}
?phyloseq::plot_richness
```

### Sample grouping & box plot

The last plot looks a bit better.
To actually make them box plots we'll change the x axis so they are based on media rather than individual samples.

The `phyloseq::plot_richness()` function produces a `ggplot2` object.
To convert our dot plot into a box plot we can add the layer `geom_boxplt()` like with our [depth boxplots](#depth-boxplots).
This will combine samples from one media into one IQR box.

```{r , eval = FALSE}
phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "media",
                        measures = c("Observed","Chao1","Shannon") +
            ggplot2::geom_boxplot()
```

### Save and display as png

Like we have done a few times we can save the plot as a png and view it.

```{r , eval = FALSE}
# Produce ggplot object of boxplot
alpha_boxplot <- phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "media",
                        measures = c("Observed","Chao1","Shannon") +
                          ggplot2::geom_boxplot()
#Save ggplot2 object with ggsave
ggsave(filename = "./Alpha_diversity_media_boxplot.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 150, width = 250)
#Display plot
IRdisplay::display_png(file="./Alpha_diversity_media_boxplot.png")
```

How do I choose a good height and width?
This comes down to trial and error and experience.
You want something with a good aspect ration for the plot and you want all the text to be clear.
Additionally, the size requirements of figures for journals will play a big consideration as well.
One of the nice things with creating jupyter-notebooks or R markdowns with all your code is that you can go back, edit, and rerun the code relatively easily and quickly.

## Alpha: stats

Along with the plot it is also good to carry otu statistics.
This will allow us to statistically determine if the alpha diversity values between groups are statistically significant.

Before carrying out statistics we will need a data frame with the alpha diveristy values for each sample.
This can be carried out with the function`phyloseq::estimate_richness()`.

```{r, eval=FALSE}
#Produce data frame of all alpha diversity values
alpha_df <- phyloseq::estimate_richness(physeq = pseq_rarefy)
head(alpha_df)
```

We have all the alpha metrics in the new data frame.
Additionally, we also have the standard error for some of the metrics (e.g. `se.chao1`).

With this information we can carry out a pairwise comparison using Wilcoxon rank sum test (the same way as QIIME2).
Base R comes with the function `pairwsie.wilcox.test()` to carry this out.
We'll do this using media as our groups from the `sample_data()` and the Observed metric from the 

```{r, eval=FALSE}
#Paired wilcoxon test
#Observed
pairwise.wilcox.test(alpha_df$Observed, phyloseq::sample_data(pseq_rarefy)$media)
```

You can ignore the warning messages in this case.

Observe the results.

```{r, echo = FALSE}
opts_p <- c(answer="__Yes__", "__No__")
```
Are all the pairwise comparisons significant different (<0.05)? `r longmcq(opts_p)`

The test has carried out P value adjustments using the Holm-Bonferroni method (`P value adjustment method: holm`) which is good.

In this case the p-values are all identical as the values do not vary greatly but there are clear differences.
The only group with a large variance is the ENV group with values going from < 150 to > 450.

### Alpha stats task

Carry out the same statistical analysis (media as the grouping) with the `Chao1` and `Shannon` metrics.

`r hide("Alpha stats solution")`
```{r, eval=FALSE}
#Chao1
pairwise.wilcox.test(alpha_df$Chao1, phyloseq::sample_data(pseq_rarefy)$media)
#Shannon
pairwise.wilcox.test(alpha_df$Shannon, phyloseq::sample_data(pseq_rarefy)$media)
```
`r unhide()`

With these we can see that the differences between the Chao1 values of the different media are significantly different.

However, the p-values when comparing the Shannon values are not all significant.
The only significant differences are between ENV & KBC, and between KBC & TSA. 
Going back to the boxplot, does this look like the case?
I would say yes as the IQRs for CVP, KBC, and TSA all overlap.
There is little to no overlap of the IQRs of KBC and TSA against ENV.

We can therefore make these claims about the alpha diversity values of the groups.

- ENV has the highest number of observed ASVs and the highest diversity.
- ENV appears to have a wider range of diversities across its samples.
- The medias have much lower numbers of ASVs and diveristy compared to ENV.
- Within each media grouping the samples have very similar numbers of ASVs present.

## Alpha diversity: violin plot

Boxplots are quite nice but violin plots can be even nicer.
They show the distribution of the data in the IQR better and in fact you can easily display each value.

We can change our boxplot to a violin plot by changing `ggplot2:geom_boxplot()` to `ggplot2::geom_violin()`.

Copy and paste the previous boxplot code to a new cell at the bottom of your notebook.
Edit and run the code so it looks like the below.

__Tip:__ Remember to change the name of your png file in the `ggsave()` and `IRdisplay::display_png()` functions.

```{r , eval = FALSE}
# Produce ggplot object of violin plot
alpha_boxplot <- phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "media",
                        measures = c("Observed","Chao1","Shannon") +
                          ggplot2::geom_boxplot()
#Save ggplot2 object with ggsave
ggsave(filename = "./Alpha_diversity_media_boxplot.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 150, width = 250)
#Display plot
IRdisplay::display_png(file="./Alpha_diversity_media_boxplot.png")
```

We can also add semi transparent dots representing the values for each sample.
To do this, add the `ggplot2` layer `ggforce::geom_sina()`.
This has the option `alpha=0.5` where alpha resents the transparency of the dots and 0.5 represents 50% transparency.
Alpha is a common option used for many plots.

```{r , eval = FALSE}
# Produce ggplot object of violin plot
alpha_boxplot <- phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "media",
                        measures = c("Observed","Chao1","Shannon") +
                          ggplot2::geom_boxplot() +
                          ggforce::geom_sina(alpha=0.5)
#Save ggplot2 object with ggsave
ggsave(filename = "./Alpha_diversity_media_boxplot.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 150, width = 250)
#Display plot
IRdisplay::display_png(file="./Alpha_diversity_media_boxplot.png")
```

## Alpha: Site plots and statistics

With all the knowledge, skills, and code from this chapter carry out the following tasks:

- Produce a violin plot of Observed, Chao1, Shannon, and Inverse Simpson with the Site groups.
- Carry out paired Wilcoxon test for Observed, Chao1, Shannon, and Inverse Simpson with the Site groups.

`r hide("Alpha sites solution")`
```{r , eval = FALSE}
# Produce ggplot object of violin plot
alpha_boxplot <- phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "site",
                        measures = c("Observed","Chao1","Shannon") +
                          ggplot2::geom_boxplot() +
                          ggforce::geom_sina(alpha=0.5)
#Save ggplot2 object with ggsave
ggsave(filename = "./Alpha_diversity_site_boxplot.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 150, width = 250)
#Display plot
IRdisplay::display_png(file="./Alpha_diversity_site_boxplot.png")
```

```{r, eval=FALSE}
#Paired wilcoxon test
#Observed
pairwise.wilcox.test(alpha_df$Observed, phyloseq::sample_data(pseq_rarefy)$site)
#Chao1
pairwise.wilcox.test(alpha_df$Chao1, phyloseq::sample_data(pseq_rarefy)$site)
#Shannon
pairwise.wilcox.test(alpha_df$Shannon, phyloseq::sample_data(pseq_rarefy)$site)
```
`r unhide()`

The plots and stats do not show anything particularly interesting in terms of site unfortunately.
There is too much difference caused by the media.
To view this we can add the option `aes(colour=media)` to `ggforce_sina()`.
This will colour the points by media.

If we only do this it will give us a legend with the title "colour".
We can fix this by adding the layer `ggplot2::labs(colour = "Media").

```{r , eval = FALSE}
# Produce ggplot object of violin plot
alpha_boxplot <- phyloseq::plot_richness(physeq = pseq_rarefy, 
                        x = "site",
                        measures = c("Observed","Chao1","Shannon") +
                          ggplot2::geom_boxplot() +
                          ggforce::geom_sina(alpha=0.5, aes(colour=media)) +
                          ggplot2::labs(colour = "Media")
#Save ggplot2 object with ggsave
ggsave(filename = "./Alpha_diversity_site_boxplot.png", plot = phylum_bar,
       device = "png", dpi = 300, units = "mm", height = 150, width = 250)
#Display plot
IRdisplay::display_png(file="./Alpha_diversity_site_boxplot.png")
```

## Alpha: recap

In this chapter we have created alpha diversity plots and run pairwise comparisons.
The biggest difference between samples is caused by the media choice which overwrites differences we can see between sites.
The environmental samples have much higher diversirty samples than the media samples but this is expected.



<!--chapter:end:15-Alpha.Rmd-->

